<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Protocol Stack &mdash; SUP PROTOCOL</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=4d935f96"></script>
        <script src="_static/doctools.js?v=9bcbadda"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Welcome to sup-protocol’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            sup-protocol
          </a>
              <div class="version">
                2.4.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Protocol Stack</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#architecture">Architecture</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#application-layer">Application Layer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#_CPPv46InvokeRK8AnyValueR8AnyValue"><code class="docutils literal notranslate"><span class="pre">Invoke()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#_CPPv47ServiceRK8AnyValueR8AnyValue"><code class="docutils literal notranslate"><span class="pre">Service()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#protocol-and-transport-layer">Protocol and Transport Layer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#synchronous-transport-layer">Synchronous transport layer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#asynchronous-transport-layer">Asynchronous transport layer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#network-layer">Network Layer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#_CPPv4clRK8AnyValue"><code class="docutils literal notranslate"><span class="pre">operator()()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">sup-protocol</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Protocol Stack</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/protocol_stack.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="protocol-stack">
<h1>Protocol Stack<a class="headerlink" href="#protocol-stack" title="Link to this heading"></a></h1>
<p><cite>sup-protocol</cite> provides abstractions that allow application programmers to define and implement application specific interfaces that need to be exposed as a Remote Procedure Call (RPC) over the network. The implementation does not rely on any specific network protocol to avoid direct coupling between application level code and low-level network code.</p>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#architecture" id="id1">Architecture</a></p>
<ul>
<li><p><a class="reference internal" href="#application-layer" id="id2">Application Layer</a></p></li>
<li><p><a class="reference internal" href="#protocol-and-transport-layer" id="id3">Protocol and Transport Layer</a></p>
<ul>
<li><p><a class="reference internal" href="#synchronous-transport-layer" id="id4">Synchronous transport layer</a></p></li>
<li><p><a class="reference internal" href="#asynchronous-transport-layer" id="id5">Asynchronous transport layer</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#network-layer" id="id6">Network Layer</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="architecture">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">Architecture</a><a class="headerlink" href="#architecture" title="Link to this heading"></a></h2>
<p>The following image summarizes the relationship between the main classes and interfaces involved in exposing an application specific interface as an RPC:</p>
<img alt="_images/sup_protocol_stack.png" src="_images/sup_protocol_stack.png" />
<section id="application-layer">
<h3><a class="toc-backref" href="#id2" role="doc-backlink">Application Layer</a><a class="headerlink" href="#application-layer" title="Link to this heading"></a></h3>
<p>At the top of the diagram is the application specific code. This code defines an API in the <cite>ApplicationService</cite> interface that the programmer wishes to expose as an RPC. When the <cite>Consumer</cite> class interacts with this interface, it stays unaware of the concrete nature of the implementation. It can be a local implementation of this service (‘ConcreteService”), or a remote protocol adapter implemented via <cite>ApplicationProtocolClient</cite> class. The later forwards method calls so they can be handled by a server-side implementation.</p>
<p>To be able to expose the <cite>ApplicationService</cite> as an RPC, the application developers need to implement two concrete classes:</p>
<ul class="simple">
<li><p><cite>ApplicationProtocolClient</cite>: this class translates API calls from <cite>ApplicationService</cite> to the generic method <cite>Protocol::Invoke</cite>, defined as part of sup-protocol;</p></li>
<li><p><cite>ApplicationProtocolServer</cite>: this class does the inverse. It implements the API of <cite>Protocol</cite>, i.e. mainly its <cite>Invoke</cite> method, and translates its payload to calls on an <cite>ApplicationService</cite> implementation.</p></li>
</ul>
<p>The <cite>Protocol</cite> interface contains the following methods:</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv46InvokeRK8AnyValueR8AnyValue">
<span id="_CPPv36InvokeRK8AnyValueR8AnyValue"></span><span id="_CPPv26InvokeRK8AnyValueR8AnyValue"></span><span id="Invoke__AnyValueCR.AnyValueR"></span><span class="n"><span class="pre">ProtocolResult</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Invoke</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">AnyValue</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">input</span></span>, <span class="n"><span class="pre">AnyValue</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv46InvokeRK8AnyValueR8AnyValue" title="Link to this definition"></a><br /></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ProtocolResult indicating success or failure conditions.</p>
</dd>
</dl>
<p>The main API method that provides access to the application layer over the network.</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv47ServiceRK8AnyValueR8AnyValue">
<span id="_CPPv37ServiceRK8AnyValueR8AnyValue"></span><span id="_CPPv27ServiceRK8AnyValueR8AnyValue"></span><span id="Service__AnyValueCR.AnyValueR"></span><span class="n"><span class="pre">ProtocolResult</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Service</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">AnyValue</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">input</span></span>, <span class="n"><span class="pre">AnyValue</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">output</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv47ServiceRK8AnyValueR8AnyValue" title="Link to this definition"></a><br /></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ProtocolResult indicating success or failure conditions.</p>
</dd>
</dl>
<p>API method that can provide generic application protocol information to the caller.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <cite>input</cite> parameter for both API methods cannot be empty.</p>
</div>
<p><cite>ProtocolResult</cite> is a simple wrapper around an unsigned integer value that describes success or a failure condition. User applications can extend the existing set with their application specific error conditions. User-defined error codes should start from the value <cite>GENERIC_APPLICATION_ERROR_START</cite> for generic application frameworks and from <cite>SPECIFIC_APPLICATION_ERROR_START</cite> for concrete applications.</p>
<p>The following basic <cite>ProtocolResult</cite> objects are defined in <cite>sup-protocol</cite>:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 26.1%" />
<col style="width: 73.9%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>ProtocolResult</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Success</p></td>
<td><p>Successful call</p></td>
</tr>
<tr class="row-odd"><td><p>NotConnected</p></td>
<td><p>Error in the exchange of messages between client and server at the network layer</p></td>
</tr>
<tr class="row-even"><td><p>ClientNetworkEncodingError</p></td>
<td><p>Error when the network client cannot encode the transport packet into a network packet</p></td>
</tr>
<tr class="row-odd"><td><p>ServerNetworkEncodingError</p></td>
<td><p>Error when the network server cannot encode the transport packet into a network packet</p></td>
</tr>
<tr class="row-even"><td><p>ClientNetworkDecodingError</p></td>
<td><p>Error when the network client cannot decode the network packet into a transport packet</p></td>
</tr>
<tr class="row-odd"><td><p>ServerNetworkDecodingError</p></td>
<td><p>Error when the network server cannot decode the network packet into a transport packet</p></td>
</tr>
<tr class="row-even"><td><p>ClientTransportEncodingError</p></td>
<td><p>Error when the transport client cannot encode the Protocol input into a transport packet</p></td>
</tr>
<tr class="row-odd"><td><p>ServerTransportEncodingError</p></td>
<td><p>Error when the transport server cannot encode the Protocol input or result/output into a transport packet</p></td>
</tr>
<tr class="row-even"><td><p>ClientTransportDecodingError</p></td>
<td><p>Error when the transport client cannot extract the Protocol output from the transport packet</p></td>
</tr>
<tr class="row-odd"><td><p>ServerTransportDecodingError</p></td>
<td><p>Error when the transport server cannot extract the Protocol input from the transport packet</p></td>
</tr>
<tr class="row-even"><td><p>ClientProtocolEncodingError</p></td>
<td><p>Error when the Protocol client cannot encode its input into a protocol input</p></td>
</tr>
<tr class="row-odd"><td><p>ServerProtocolEncodingError</p></td>
<td><p>Error when the Protocol server cannot encode the application data to the protocol ouput</p></td>
</tr>
<tr class="row-even"><td><p>ClientProtocolDecodingError</p></td>
<td><p>Error when the Protocol client cannot extract the application return value(s) from the protocol packet</p></td>
</tr>
<tr class="row-odd"><td><p>ServerProtocolDecodingError</p></td>
<td><p>Error when the Protocol server cannot extract the application input from the protocol packet</p></td>
</tr>
<tr class="row-even"><td><p>ServerUnsupportedPayloadEncodingError</p></td>
<td><p>Error when the Protocol server cannot decode the payload from the transport packet</p></td>
</tr>
<tr class="row-odd"><td><p>InvalidRequestIdentifierError</p></td>
<td><p>Error when the Protocol server receives a request about an asynchronous request with an unknown identifier</p></td>
</tr>
<tr class="row-even"><td><p>InvalidAsynchronousOperationError</p></td>
<td><p>Error when the Protocol server receives a request for an asynchronous request that is not valid</p></td>
</tr>
<tr class="row-odd"><td><p>ServerProtocolException</p></td>
<td><p>Error when the Protocol at the server side throws an exception</p></td>
</tr>
<tr class="row-even"><td><p>ClientTransportException</p></td>
<td><p>Error when the injected transport AnyFunctor on the client side throws an exception</p></td>
</tr>
<tr class="row-odd"><td><p>AsynchronousProtocolTimeout</p></td>
<td><p>Error when an asynchronous request times out</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>Most predefined <cite>ProtocolResult</cite> objects can be categorized by:</dt><dd><ul class="simple">
<li><p><cite>Client</cite> or <cite>Server</cite>: indicates if the error occurred on the client or server side;</p></li>
<li><p><cite>Network</cite>, <cite>Transport</cite> or <cite>Protocol</cite>: indicates if the error occurred at the network, transport or protocol layer;</p></li>
<li><p><cite>Encoding</cite> or <cite>Decoding</cite>: indicates the direction of the data flow where an error occurred; more specifically, <cite>Encoding</cite> refers to the process of encoding data from a higher layer into a packet for the layer below, while <cite>Decoding</cite> referes to the inverse process.</p></li>
</ul>
</dd>
</dl>
</div>
</section>
<section id="protocol-and-transport-layer">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">Protocol and Transport Layer</a><a class="headerlink" href="#protocol-and-transport-layer" title="Link to this heading"></a></h3>
<p>The protocol and transport layer is defined by <cite>sup-protocol</cite>, as can be seen from the interface definitions in the diagram (<cite>Protocol</cite> and <cite>AnyFunctor</cite>) and the classes that translate between these two layers (<cite>ProtocolRPCClient</cite> and <cite>ProtocolRPCSserver</cite>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The split into a protocol and transport layer is not strictly necessary, but it allows for a more flexible design. The protocol layer is responsible for defining the structure of the messages exchanged between the client and server, while the transport layer is responsible for defining how these messages are exchanged over the network. This allows for supporting asynchronous communication over a synchronous network protocol.</p>
</div>
<p>The translation between the protocol and transport layer is done by the <cite>ProtocolRPCClient</cite> and <cite>ProtocolRPCServer</cite> classes. Multiple transport layer protocols are supported, depending on whether the transport layer is synchronous or asynchronous and whether the payload is encoded or not.</p>
<p>The choice of encoding and (a)synchronous communication is determined by the <cite>ProtocolRPCClient</cite>’s configuration. The server will respect the same transport layer protocol as requested by the client or return an error status if this is not supported.</p>
<section id="synchronous-transport-layer">
<h4><a class="toc-backref" href="#id4" role="doc-backlink">Synchronous transport layer</a><a class="headerlink" href="#synchronous-transport-layer" title="Link to this heading"></a></h4>
<p>If <cite>ProtocolRPCClient</cite> is configured to use synchronous communication over the transport layer, it will create a transport packet that is structured as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># Without encoding
struct sup::protocolRequest/v2.1
    query: &lt;payload&gt;
    encoding: int32 0 (optional)

# With base64 encoding
struct sup::protocolRequest/v2.1
    query: string &lt;base64 encoded payload&gt;
    encoding: int32 1
</pre></div>
</div>
<p>where <cite>&lt;payload&gt;</cite> represents the <cite>input</cite> parameter of the <cite>Protocol::Invoke</cite> method. In case no encoding of the payload is used, the <cite>encoding</cite> field is optional and can be omitted. Currently, only two encoding methods are supported:</p>
<ul class="simple">
<li><p>No encoding (0)</p></li>
<li><p>Base64 encoding (1): the <cite>input</cite> parameter of the <cite>Protocol::Invokde</cite> method will first be serialized into a binary format that is then base64 encoded into a string.</p></li>
</ul>
<p>The <cite>ProtocolRPCServer</cite> object at the server side will unpack this packet to extract the original <cite>input</cite> parameter, possibly using base64 decoding. It will then call the custom <cite>Protocol::Invoke</cite> method of the application and create a return packet as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span> # Without encoding
struct sup::protocolReply/v2.1
    result: uint32 0
    reply: &lt;payload&gt;
    encoding: int32 0 (optional)

# With base64 encoding
struct sup::protocolReply/v2.1
    result: uint32 0
    reply: string &lt;base64 encoded payload&gt;
    encoding: int32 1
</pre></div>
</div>
<p>where <cite>&lt;payload&gt;</cite> now refers to the <cite>output</cite> parameter of the <cite>Protocol::Invoke</cite> method. The <cite>result</cite> field encodes the return value of the <cite>Protocol::Invoke</cite> method.</p>
</section>
<section id="asynchronous-transport-layer">
<h4><a class="toc-backref" href="#id5" role="doc-backlink">Asynchronous transport layer</a><a class="headerlink" href="#asynchronous-transport-layer" title="Link to this heading"></a></h4>
<p>For simplicity, in this section all packets are shown without encoding. If base64 encoding would be used, this would add the member field <cite>encoding</cite> to the packet and both <cite>query</cite> and <cite>reply</cite> would be base64 encoded strings.</p>
<p>If <cite>ProtocolRPCClient</cite> is configured to use asynchronous communication over the transport layer, it will first send an initial request packet to the server that is encoded as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>struct sup::protocolRequest/v2.1
    query: &lt;payload or encoded payload&gt;
    async: uint32 0
</pre></div>
</div>
<p>If the server does not support the asynchronous transport protocol, it will ignore the <cite>async</cite> field and process the request as a synchronous request. If the server does support the asynchronous transport protocol, it will process the request and return a packet that is structured as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>struct sup::protocolReply/v2.1
    result: uint32 0
    reply: struct
        id: uint64 &lt;request_id&gt;
    async: uint32 0
</pre></div>
</div>
<p>where <cite>&lt;request_id&gt;</cite> is a unique integer identifier for the request.</p>
<p>The client will then poll the server to check if the request has been processed. The polling packets are structured as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># Poll request
struct sup::protocolRequest/v2.1
    query: struct
        id: uint64 &lt;request_id&gt;
    async: uint32 1

 # Poll reply
 struct sup::protocolReply/v2.1
     result: uint32 0
     reply: struct
         ready: bool &lt;true/false&gt;
     async: uint32 1
</pre></div>
</div>
<p>If the poll reply indicates that the initial request has been fully processed, the client will attempt to retrieve the result of this processing by sending a request packet that is structured as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>struct sup::protocolRequest/v2.1
    query: struct
        id: uint64 &lt;request_id&gt;
    async: uint32 2
</pre></div>
</div>
<p>And the server will return the result of the processing in a packet that is structured as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>struct sup::protocolReply/v2.1
    result: uint32 0
    reply: &lt;payload&gt;
    async: uint32 2
</pre></div>
</div>
</section>
</section>
<section id="network-layer">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Network Layer</a><a class="headerlink" href="#network-layer" title="Link to this heading"></a></h3>
<p>At the bottom part of the diagram is the network implementation (the diagram uses a concrete EPICS implementation). Every concrete network implemenation should implement the <cite>AnyFunctor</cite> interface:</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4clRK8AnyValue">
<span id="_CPPv3clRK8AnyValue"></span><span id="_CPPv2clRK8AnyValue"></span><span id="call-operator__AnyValueCR"></span><span class="n"><span class="pre">AnyValue</span></span><span class="w"> </span><span class="sig-name descname"><span class="k"><span class="pre">operator</span></span><span class="o"><span class="pre">()</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">AnyValue</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">input</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4clRK8AnyValue" title="Link to this definition"></a><br /></dt>
<dd><p>The function call operator with an <cite>AnyValue</cite> parameter and return value.</p>
</dd></dl>

<p>An implementation of the network layer requires:</p>
<ul class="simple">
<li><p>The client and server implementations obey the contract of the transport layer. This means that the return values of the function call operator are compliant with the above mentioned reply structures.</p></li>
</ul>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to sup-protocol’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright ITER Organization.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>